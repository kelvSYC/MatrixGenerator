#include "Group.h"
#include "utils.h"

#include <vector>

#include <boost/any.hpp>

#ifndef MatrixGenerator_Pruner_h
#define MatrixGenerator_Pruner_h

/**
 * CandidateGenerator is the abstract superclass for all classes that create a list of orbit representative candidates
 * for k-subsets from orbit representative candidates for (k-1)-subsets.
 */
class CandidateGenerator {
	size_t v;
	std::vector<Subset> orbitReps;
protected:
	CandidateGenerator(size_t _v, const std::vector<Subset>& _orbitReps) : v(_v), orbitReps(_orbitReps) {}
	
	template <class InputIterator>
	CandidateGenerator(size_t v, InputIterator begin, InputIterator end) : orbitReps(begin, end) {}
public:
	virtual ~CandidateGenerator() {}
	
	size_t getNumPoints() const { return v; }
	const std::vector<Subset>& getOldReps() const { return orbitReps; }
	
	virtual std::vector<Subset> generateCandidates() const = 0;
};

/**
 * It is noted that if A is a orbit representative for k-subsets, then A less the greatest element within is an orbit
 * representative for (k-1)-subsets.  The DefaultCandidateGenerator creates orbit representative candidates based on this.
 */
struct DefaultCandidateGenerator : public CandidateGenerator {
	DefaultCandidateGenerator(size_t v, const std::vector<Subset>& orbitReps) : CandidateGenerator(v, orbitReps) {}
	
	template <class InputIterator>
	DefaultCandidateGenerator(size_t v, InputIterator begin, InputIterator end) : CandidateGenerator(v, begin, end) {}
	
	std::vector<Subset> generateCandidates() const;
};

/**
 * The FullCandidateGenerator creates orbit representative candidates for k-subsets by taking a (k-1)-representative and
 * adding a member of X not found therein.  Because of the observation stated in DefaultCandidateGenerator, this generator
 * should be avoided unless there is a compelling reason that this generator should be used.
 */
struct FullCandidateGenerator : public CandidateGenerator {
	FullCandidateGenerator(size_t v, const std::vector<Subset>& orbitReps) : CandidateGenerator(v, orbitReps) {}
	
	template <class InputIterator>
	FullCandidateGenerator(size_t v, InputIterator begin, InputIterator end) : CandidateGenerator(v, begin, end) {}
	
	std::vector<Subset> generateCandidates() const;
};

/* ******************************************************************************************************************** */

/**
 * A Pruner takes a list of orbit representative candidates and reduces them down to the list of orbit representatives.
 */
class Pruner {
	std::vector<Subset> candidates;
public:
	virtual ~Pruner() {}
	
	/**
	 * Prunes the list of candidates.
	 */
	virtual void prune() = 0;
	
	/**
	 * Returns the list of candidates.
	 */
	std::vector<Subset> getCandidates() { return candidates; }
	
	/**
	 * Returns the set of k-representatives.
	 *
	 * Precondition: prune() has been called exactly once.
	 */
	virtual std::vector<Subset> getNewReps() = 0;
	
	/**
	 * Returns any auxilliary information generated by the pruner, suitable for use in the next iteration.
	 * By default, this returns a blank any, representing the absence of auxilliary information.
	 *
	 * Note that the information contained therein may not be useful to the pruner used in the next iteration.
	 */
	virtual boost::any getNewData() { return boost::any(); }
	
	/**
	 * Returns the index in the orbit representative list corresponding to the representative of the input
	 * k-subset.
	 *
	 * Precondition: prune() has already been called exactly once.
	 */
	virtual size_t getColumn(const Subset& candidate) = 0;
protected:
	/**
	 * Constructs a new pruner.
	 *
	 * @param <GeneratorType> The orbit representative candidate generator type.
	 * @param rho The number of orbit representatives.  This must be greater than 1.
	 * @param candidates The orbit representative candidates.
	 */
	template <class GeneratorType>
	Pruner(const Group& _G, unsigned long _rho, GeneratorType generator) : G(_G.shared_from_this()), rho(_rho), candidates(generator.generateCandidates()) {}
	
	boost::shared_ptr<const Group> G;
	unsigned long rho;				// Number of orbit representatives
};

/**
 * Exception class thrown whenever a method that retrieves processed data is called before prune() has been called.
 */
struct PrunerNotReady : public std::logic_error {
	PrunerNotReady() : std::logic_error("Pruner not ready") {}
};

#endif
